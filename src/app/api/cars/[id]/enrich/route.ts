import { NextResponse } from "next/server";
import { ObjectId } from "mongodb";
import { getMongoClient } from "@/lib/mongodb";
import { Car, MeasurementValue } from "@/types/car";

export const dynamic = "force-dynamic";

interface SerperResult {
  organic: Array<{
    title: string;
    link: string;
    snippet: string;
    position: number;
  }>;
  searchParameters: {
    q: string;
    num: number;
  };
}

// Helper function to get MongoDB client
async function searchVehicleInfo(query: string) {
  // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] console.log(`\nüîç Searching Serper for: "${query}"`);
  const response = await fetch("https://google.serper.dev/search", {
    method: "POST",
    headers: {
      "X-API-KEY": process.env.SERPER_API_KEY || "",
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      q: query,
      num: 10,
    }),
  });

  if (!response.ok) {
    console.error("‚ùå Serper API error:", response.statusText);
    throw new Error(`Serper API error: ${response.statusText}`);
  }

  const results = await response.json();
  // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] console.log(`‚úÖ Found ${results.organic?.length || 0} organic results`);
  return results;
}

async function cleanAndStructureData(
  searchResults: SerperResult[],
  existingCarData: Car
): Promise<Partial<Car>> {
  // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] console.log("\nüßπ Cleaning and structuring search data...");

  // Generate specific questions based on missing fields and car details
  const questions = [];
  const baseCarInfo = `${existingCarData.year} ${existingCarData.make} ${existingCarData.model}`;
  const seriesInfo = existingCarData.manufacturing?.series
    ? ` ${existingCarData.manufacturing.series}`
    : "";
  const trimInfo = existingCarData.manufacturing?.trim
    ? ` ${existingCarData.manufacturing.trim}`
    : "";
  const fullCarInfo = `${baseCarInfo}${seriesInfo}${trimInfo}`;

  // Engine-related questions
  if (
    !existingCarData.engine?.power?.hp ||
    existingCarData.engine.power.hp === 0
  ) {
    questions.push(
      `What is the exact horsepower output of the ${fullCarInfo}?`
    );
  }
  if (
    !existingCarData.engine?.torque?.["lb-ft"] ||
    existingCarData.engine.torque["lb-ft"] === 0
  ) {
    questions.push(
      `What is the torque output (in lb-ft and Nm) of the ${fullCarInfo}?`
    );
  }
  if (!existingCarData.engine?.displacement?.value) {
    questions.push(`What is the engine displacement of the ${fullCarInfo}?`);
  }

  // Dimension-related questions
  if (!existingCarData.dimensions?.weight?.value) {
    questions.push(`What is the curb weight of the ${fullCarInfo}?`);
  }
  if (!existingCarData.dimensions?.wheelbase?.value) {
    questions.push(`What is the wheelbase length of the ${fullCarInfo}?`);
  }
  if (!existingCarData.dimensions?.trackWidth?.value) {
    questions.push(`What is the track width of the ${fullCarInfo}?`);
  }

  // Color and interior questions
  if (!existingCarData.color || existingCarData.color === "") {
    questions.push(
      `What were the available exterior colors for the ${fullCarInfo}?`
    );
  }
  if (
    !existingCarData.interior_color ||
    existingCarData.interior_color === ""
  ) {
    questions.push(
      `What were the available interior colors/materials for the ${fullCarInfo}?`
    );
  }

  // Additional specific questions based on series/trim
  if (existingCarData.manufacturing?.series === "GT3") {
    questions.push(
      `What are the specific performance features of the ${fullCarInfo}?`,
      `What are the aerodynamic elements of the ${fullCarInfo}?`,
      `What is the downforce generated by the ${fullCarInfo}?`
    );
  }

  const response = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: `You are a vehicle data specialist focusing on extracting and validating specific technical information about cars. Your task is to analyze search results and answer specific questions about a vehicle, providing only high-confidence information that matches the exact vehicle specification (year, make, model, series, and trim).

Rules:
1. Only provide information if you are highly confident it matches the exact vehicle specification
2. For measurements, always include both value and unit in the specified format
3. For colors, only list factory/official colors
4. Distinguish between standard features and optional features
5. If information is trim-specific, clearly indicate which trim it applies to
6. If you cannot find specific information for a particular trim, provide the base model information and clearly indicate this
7. NEVER modify or include the following protected fields in your response:
   - Year
   - Make
   - Model
   - Color
   - Mileage
   - VIN
   - Client
   - Location
   - Price
8. If you cannot find confident information for a field, return null

You MUST return data in this exact structure:
{
  "engine": {
    "torque": {
      "lb-ft": number,
      "Nm": number
    },
    "features": string[]
  },
  "dimensions": {
    "length": {
      "value": number,
      "unit": string
    },
    "width": {
      "value": number,
      "unit": string
    },
    "height": {
      "value": number,
      "unit": string
    },
    "wheelbase": {
      "value": number,
      "unit": string
    },
    "weight": {
      "value": number,
      "unit": string
    },
    "trackWidth": {
      "value": number,
      "unit": string
    },
    "gvwr": {
      "value": number,
      "unit": string
    }
  },
  "interior_color": string
}

For example:
{
  "engine": {
    "torque": {
      "lb-ft": 300,
      "Nm": 405
    },
    "features": [
      "3.6L Flat 6 engine",
      "415 hp @ 7600 rpm",
      "Variable valve timing"
    ]
  },
  "dimensions": {
    "length": {
      "value": 178.9,
      "unit": "in"
    },
    "width": {
      "value": 72.9,
      "unit": "in"
    },
    "height": {
      "value": 50.4,
      "unit": "in"
    },
    "wheelbase": {
      "value": 92.9,
      "unit": "in"
    },
    "weight": {
      "value": 3031,
      "unit": "lbs"
    },
    "trackWidth": {
      "value": 61.2,
      "unit": "in"
    },
    "gvwr": {
      "value": 3850,
      "unit": "lbs"
    }
  },
  "interior_color": "Black"
}

Return a JSON object with validated data that EXACTLY matches this structure.`,
        },
        {
          role: "user",
          content: `Extract and validate information for the ${fullCarInfo} by answering these specific questions:\n\n${questions.join(
            "\n"
          )}\n\nSearch results: ${JSON.stringify(searchResults)}`,
        },
      ],
      temperature: 0.3,
      max_tokens: 1000,
      response_format: { type: "json_object" },
    }),
  });

  if (!response.ok) {
    console.error("‚ùå OpenAI API error:", response.statusText);
    throw new Error(`OpenAI API error: ${response.statusText}`);
  }

  const data = await response.json();
  const aiData = JSON.parse(data.choices[0].message.content);
  // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] console.log("‚úÖ Data cleaned and structured:", aiData);

  // Transform the AI response into our car data structure
  const enrichedData: Partial<Car> = {
    ...existingCarData,
    engine: {
      ...existingCarData.engine,
      // Only update torque if it's missing or has no value
      torque:
        !existingCarData.engine?.torque?.["lb-ft"] ||
        existingCarData.engine.torque["lb-ft"] === 0
          ? aiData.engine?.torque
          : existingCarData.engine?.torque,
      // Only update features if they're missing or empty
      features:
        !existingCarData.engine?.features ||
        existingCarData.engine.features.length === 0
          ? aiData.engine?.features
          : existingCarData.engine?.features,
    },
    dimensions: {
      ...existingCarData.dimensions,
      // Only update dimensions if they're missing or have no value
      length: !existingCarData.dimensions?.length?.value
        ? aiData.dimensions?.length
        : existingCarData.dimensions?.length,
      width: !existingCarData.dimensions?.width?.value
        ? aiData.dimensions?.width
        : existingCarData.dimensions?.width,
      height: !existingCarData.dimensions?.height?.value
        ? aiData.dimensions?.height
        : existingCarData.dimensions?.height,
      wheelbase: !existingCarData.dimensions?.wheelbase?.value
        ? aiData.dimensions?.wheelbase
        : existingCarData.dimensions?.wheelbase,
      weight: !existingCarData.dimensions?.weight?.value
        ? aiData.dimensions?.weight
        : existingCarData.dimensions?.weight,
      trackWidth: !existingCarData.dimensions?.trackWidth?.value
        ? aiData.dimensions?.trackWidth
        : existingCarData.dimensions?.trackWidth,
      gvwr: !existingCarData.dimensions?.gvwr?.value
        ? aiData.dimensions?.gvwr
        : existingCarData.dimensions?.gvwr,
    },
    // Only update interior color if it's missing or empty
    interior_color:
      !existingCarData.interior_color || existingCarData.interior_color === ""
        ? aiData.interior_color
        : existingCarData.interior_color,
  };

  // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] console.log("‚úÖ Transformed enriched data:", enrichedData);
  return enrichedData;
}

// Helper function to identify missing fields
function getMissingFields(car: Car): { field: string; category: string }[] {
  const missingFields = [];

  // Basic Information
  if (!car.color || car.color === "")
    missingFields.push({ field: "color", category: "appearance" });
  if (!car.interior_color || car.interior_color === "")
    missingFields.push({ field: "interior_color", category: "interior" });
  if (!car.condition || car.condition === "")
    missingFields.push({ field: "condition", category: "general" });
  if (!car.type || car.type === "")
    missingFields.push({ field: "type", category: "general" });

  // Engine Details
  if (!car.engine?.displacement?.value)
    missingFields.push({ field: "engine_displacement", category: "engine" });
  if (!car.engine?.power?.hp || car.engine.power.hp === 0)
    missingFields.push({ field: "engine_power", category: "engine" });
  if (!car.engine?.torque?.["lb-ft"] || car.engine.torque["lb-ft"] === 0)
    missingFields.push({ field: "engine_torque", category: "engine" });
  if (!car.engine?.features || car.engine.features.length === 0)
    missingFields.push({ field: "engine_features", category: "engine" });

  // Dimensions
  if (!car.dimensions?.weight?.value)
    missingFields.push({ field: "weight", category: "dimensions" });
  if (!car.dimensions?.wheelbase?.value)
    missingFields.push({ field: "wheelbase", category: "dimensions" });
  if (!car.dimensions?.trackWidth?.value)
    missingFields.push({ field: "track_width", category: "dimensions" });
  if (!car.dimensions?.gvwr?.value)
    missingFields.push({ field: "gvwr", category: "dimensions" });
  // Add basic dimensions checks
  if (!car.dimensions?.length?.value)
    missingFields.push({ field: "length", category: "dimensions" });
  if (!car.dimensions?.width?.value)
    missingFields.push({ field: "width", category: "dimensions" });
  if (!car.dimensions?.height?.value)
    missingFields.push({ field: "height", category: "dimensions" });

  return missingFields;
}

// Helper function to generate targeted search queries
function generateSearchQueries(
  car: Car,
  missingFields: { field: string; category: string }[]
): string[] {
  const baseInfo = `${car.year} ${car.make} ${car.model}`;
  const seriesInfo = car.manufacturing?.series
    ? ` ${car.manufacturing.series}`
    : "";
  const trimInfo = car.manufacturing?.trim ? ` ${car.manufacturing.trim}` : "";
  const fullCarInfo = `${baseInfo}${seriesInfo}${trimInfo}`;

  const queries = [];

  // Group missing fields by category
  const fieldsByCategory = missingFields.reduce((acc, { field, category }) => {
    if (!acc[category]) acc[category] = [];
    acc[category].push(field);
    return acc;
  }, {} as Record<string, string[]>);

  // Generate specific queries for each category
  Object.entries(fieldsByCategory).forEach(([category, fields]) => {
    switch (category) {
      case "engine":
        if (
          fields.includes("engine_power") ||
          fields.includes("engine_torque")
        ) {
          queries.push(
            `${fullCarInfo} engine power output torque specifications`
          );
        }
        if (fields.includes("engine_displacement")) {
          queries.push(
            `${fullCarInfo} engine displacement cubic capacity specifications`
          );
        }
        if (fields.includes("engine_features")) {
          queries.push(
            `${fullCarInfo} engine technical features specifications`
          );
        }
        break;

      case "dimensions":
        if (fields.includes("weight")) {
          queries.push(`${fullCarInfo} curb weight specifications`);
        }
        if (fields.includes("wheelbase") || fields.includes("track_width")) {
          queries.push(`${fullCarInfo} wheelbase track width dimensions`);
        }
        if (fields.includes("gvwr")) {
          queries.push(`${fullCarInfo} gross vehicle weight rating GVWR`);
        }
        // Add specific query for basic dimensions
        if (
          fields.includes("length") ||
          fields.includes("width") ||
          fields.includes("height")
        ) {
          queries.push(
            `${fullCarInfo} exterior dimensions length width height specifications`
          );
        }
        break;

      case "appearance":
        if (fields.includes("color")) {
          queries.push(`${fullCarInfo} factory exterior paint colors options`);
        }
        break;

      case "interior":
        if (fields.includes("interior_color")) {
          queries.push(`${fullCarInfo} interior colors upholstery options`);
        }
        break;
    }
  });

  // Add model-specific queries based on series/trim
  if (car.manufacturing?.series === "GT3") {
    queries.push(
      `${fullCarInfo} aerodynamic features downforce`,
      `${fullCarInfo} GT3 specific performance upgrades`,
      `${fullCarInfo} GT3 technical specifications differences from standard model`
    );
  }

  return queries;
}

export async function POST(request: Request) {
  try {
    const url = new URL(request.url);
    const segments = url.pathname.split("/");
    const id = segments[segments.length - 2];

    // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] console.log("\nüöÄ Starting car data enrichment process...");
    const client = await getMongoClient();

    try {
      const db = client.db(process.env.MONGODB_DB || "motive_archive");
      const collection = db.collection("cars");
      const carId = new ObjectId(id);

      // Get existing car data
      const existingCarData = await collection.findOne<Car>({ _id: carId });
      if (!existingCarData) {
        throw new Error("Car not found");
      }

      // Identify missing fields
      const missingFields = getMissingFields(existingCarData);
      // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] console.log("Missing fields:", missingFields);

      // Generate targeted search queries
      const searchQueries = generateSearchQueries(
        existingCarData,
        missingFields
      );
      // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] // [REMOVED] console.log("Generated search queries:", searchQueries);

      // Perform searches concurrently
      const searchPromises = searchQueries.map((query) =>
        searchVehicleInfo(query)
      );
      const searchResults = await Promise.all(searchPromises);

      // Clean and structure the data
      const enrichedData = await cleanAndStructureData(
        searchResults,
        existingCarData
      );

      // Preserve protected fields
      const updatedCarData = {
        ...enrichedData,
        _id: existingCarData._id,
        year: existingCarData.year,
        make: existingCarData.make,
        model: existingCarData.model,
        color: existingCarData.color,
        mileage: existingCarData.mileage,
        vin: existingCarData.vin,
        client: existingCarData.client,
        location: existingCarData.location,
        price: existingCarData.price,
      };

      // Update the car in the database
      await collection.updateOne({ _id: carId }, { $set: updatedCarData });

      return NextResponse.json({
        success: true,
        message: "Car data enriched successfully",
        data: updatedCarData,
        progress: {
          step: 6,
          currentStep: "Complete",
          status: "complete",
          details: {
            missingFields,
            searchQueriesGenerated: searchQueries.length,
            searchesCompleted: searchResults.length,
            fieldsUpdated: Object.keys(enrichedData).length,
            protectedFieldsPreserved: [
              "year",
              "make",
              "model",
              "color",
              "mileage",
              "vin",
              "client",
              "location",
              "price",
            ],
          },
        },
      });
    } catch (error) {
      console.error("‚ùå Error enriching car data:", error);
      return NextResponse.json(
        {
          success: false,
          message: "Failed to enrich car data",
          error:
            error instanceof Error ? error.message : "Unknown error occurred",
          progress: {
            step: 0,
            currentStep: "",
            status: "error",
            error:
              error instanceof Error ? error.message : "Unknown error occurred",
          },
        },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("Error:", error);
    return NextResponse.json(
      {
        error:
          error instanceof Error ? error.message : "Failed to enrich car data",
      },
      { status: 500 }
    );
  }
}

// OPTIONS handler for CORS
export async function OPTIONS(request: Request) {
  return new NextResponse(null, {
    status: 204,
    headers: {
      "Access-Control-Allow-Methods": "POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Allow-Origin": "*",
    },
  });
}
